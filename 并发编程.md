# synchronized + wait+ nofify

## Code 
```Java []
synchronized (lock) {
    if (condition) {
        lock.wait();
    }
    // 执行后续操作
    lock.notify();
}
```
tips: 这样的代码可能会在没有明确通知的情况下被唤醒，即使条件 condition 为假。因此，在唤醒后，线程可能会继续执行后续操作，而实际上并没有符合预期的条件。这会导致程序逻辑错误。

## Code
```Java []
synchronized (lock) {
    while (condition) {
        lock.wait();
    }
    // 执行后续操作
    lock.notify();
}
```
即使线程在没有明确通知的情况下被唤醒，它会重新检查条件。如果条件仍然为真，线程将继续等待；如果条件为假，线程将继续执行后续操作。
使用 while 循环能够更好地保护代码免受虚假唤醒的影响，确保在满足特定条件之前，线程一直等待。


# Semaphore
> acquire 方法获取许可，如果许可为空0，则会阻塞，release方法释放许可，每执行一次许可+1。
> 如下代码显示许可初始化为0 的情况，release 3次后，许可数量是3。
## 结论：许可的数量permits = permits+ n （n为release执行次数）

## Code
```Java []
public static void main(String[] args) throws InterruptedException {
    // 信号量
    Semaphore semaphore = new Semaphore(0, true);

    Thread threadA = new Thread(() -> {
        System.out.println("Thread A is waiting to acquire a permit");
        try {
            semaphore.acquire();
            System.out.println("Thread A has acquired a permit");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, "A");

    Thread threadB = new Thread(() -> {
        System.out.println("Thread B is Releasing a permit");
        // 次数连续调用释放三次，则许可的数量会是三个，release() 方法的作用是等同于 permit++的效果
        semaphore.release();
        semaphore.release();
        semaphore.release();
        System.out.println("Thread B has Released a permit");
    }, "B");

    // B线程先启动，并释放三次许可
    threadB.start();
    Thread.sleep(3000);
    // 初始的信号量为0,结果是3
    System.out.println("当前可用许可:" + semaphore.availablePermits());
    threadA.start();
 }
```
